# from django.db import models
# from paystackapi.paystack import Paystack
# from django.conf import settings

# from paystackapi.customer import Customer
# from paystackapi.verification import Verification
# from django.contrib.auth import get_user_model

# paystack_secret_key = settings.PAYSTACK_SECRET_KEY
# paystack = Paystack(secret_key=paystack_secret_key)

# User = get_user_model()



# class OrderManagerQuerySet(models.query.QuerySet):
#     def recent(self):
#         return self.order_by("-created", "-updated")

#     def get_sales_breakdown(self):
#         recent = self.recent().not_refunded()
#         recent_data = recent.totals_data()
#         recent_cart_data = recent.cart_data()
#         shipped = recent.not_refunded().by_status(status='shipped')
#         shipped_data = shipped.totals_data()
#         paid = recent.by_status(status='paid')
#         paid_data = paid.totals_data()
#         data = {
#             'recent': recent,
#             'recent_data':recent_data,
#             'recent_cart_data': recent_cart_data,
#             'shipped': shipped,
#             'shipped_data': shipped_data,
#             'paid': paid,
#             'paid_data': paid_data
#         }
#         return data

#     def by_weeks_range(self, weeks_ago=7, number_of_weeks=2):
#         if number_of_weeks > weeks_ago:
#             number_of_weeks = weeks_ago
#         days_ago_start = weeks_ago * 7  # days_ago_start = 49
#         days_ago_end = days_ago_start - (number_of_weeks * 7) #days_ago_end = 49 - 14 = 35
#         start_date = timezone.now() - datetime.timedelta(days=days_ago_start)
#         end_date = timezone.now() - datetime.timedelta(days=days_ago_end)
#         return self.by_range(start_date, end_date=end_date)

#     def by_range(self, start_date, end_date=None):
#         if end_date is None:
#             return self.filter(updated__gte=start_date)
#         return self.filter(updated__gte=start_date).filter(updated__lte=end_date)

#     def by_date(self):
#         now = timezone.now() - datetime.timedelta(days=9)
#         return self.filter(updated__day__gte=now.day)

#     def totals_data(self):
#         return self.aggregate(Sum("total"), Avg("total"))

#     def cart_data(self):
#         return self.aggregate(
#                         Sum("cart__products__price"),
#                         Avg("cart__products__price"),
#                         Count("cart__products")
#                                     )

#     def by_status(self, status="shipped"):
#         return self.filter(status=status)

#     def not_refunded(self):
#         return self.exclude(status='refunded')

#     def by_request(self, request):
#         billing_profile, created = BillingProfile.objects.new_or_get(request)
#         return self.filter(billing_profile=billing_profile)

#     def not_created(self):
#         return self.exclude(status='created')

# class OrderManager(models.Manager):
#     def get_queryset(self):
#         return OrderManagerQuerySet(self.model, using=self._db)

#     def by_request(self, request):
#         return self.get_queryset().by_request(request)

#     def new_or_get(self, billing_profile, cart_obj):
#         created = False
#         qs = self.get_queryset().filter(
#                 billing_profile=billing_profile,
#                 cart=cart_obj,
#                 active=True,
#                 status='created'
#             )
#         if qs.count() == 1:
#             obj = qs.first()
#         else:
#             obj = self.model.objects.create(
#                     billing_profile=billing_profile,
#                     cart=cart_obj)
#             created = True
#         return obj, created

# class ProductPurchaseQuerySet(models.query.QuerySet):
#     def active(self):
#         return self.filter(refunded=False)

#     def digital(self):
#         return self.filter(product__is_digital=True)

#     def by_request(self, request):
#         billing_profile, created = BillingProfile.objects.new_or_get(request)
#         return self.filter(billing_profile=billing_profile)



# class ProductPurchaseManager(models.Manager):
#     def get_queryset(self):
#         return ProductPurchaseQuerySet(self.model, using=self._db)

#     def all(self):
#         return self.get_queryset().active()

#     def digital(self):
#         return self.get_queryset().active().digital()

#     def by_request(self, request):
#         return self.get_queryset().by_request(request)

#     def products_by_id(self, request):
#         qs = self.by_request(request).digital()
#         ids_ = [x.product.id for x in qs]
#         return ids_

#     def products_by_request(self, request):
#         ids_ = self.products_by_id(request)
#         products_qs = Product.objects.filter(id__in=ids_).distinct()
#         return products_qs
